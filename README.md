# 程設專題
## Project 1 Maximal Points Problem
一、題目內容
在一個空間中有 p 和 q 兩個點，當 p.x >= q.x、p.y >= q.y 以及 p.z >= q.z 成立時稱為 p dominates q。
當一個在點集合 S 中的 p 點不被任何其他屬於 S 的點 dominates 時，該 p 點就被稱作為一個 maximal point。

目標：將所有屬於 S 的 maximal points 找出來。
 

二、實作方法
（一） 暴力求解
從第 1 個點到第 n 個點，每個點都跟自己以外的所有點比較，若沒有任何一個點 dominate 它，即為 maximal point。
優化：一旦遇到 dominate 它的點，即可保證它非 maximal point，因此可直接跳出迴圈並記錄此點，不再比較。

（二） 分治
首先將所有的點依照 x 優先、y 次之、z 最後的優先順序做降序排列。之後將排序後的集合從中間切半，分成大小相等的兩個部分，令 a 為 x 值較大的一半，b 則為較小的一半。這時候可以保證 a 集合中點的 x 值必定大於等於 b 中的點，此時將 a 與 b 中的點做比較，便可忽略 x 值，將其降為僅考慮 y 和 z 的二維 maximal point 問題。

## Project 2 Making Binary Search Dynamic
一、	題目內容
![](https://i.imgur.com/Ya32hq6.png)
 
二、	實作方法
（一）	架構
根據題目，建立k個陣列（A0, A1, …, Ak-1）並將n個數字放入其中，第i個陣列Ai的長度為2i，且所有陣列只會有全滿與全空兩個狀態。
因陣列長度不一，故選擇vector作為容器；另外，由於後續還會插入未知數量的數字，因此最初宣告的陣列數會大於k。

（二）	Search
基本上使用基礎的binary search方法實作，設定左右邊界並逐次砍半，直至找到目標數字。惟因此架構不只一陣列，須依序搜尋所有不為空的陣列。

（三）	Insert
首先須用Search確定所有陣列中皆無要插入的數字。
建立一個暫存陣列，將要插入的數字放入。判斷A0狀態，若A0為空，則將暫存陣列的內容移至A0；否則將暫存陣列與A0合併，判斷A1狀態。若A1仍不為空，則將合併後的暫存陣列與A1合併，判斷A2狀態，以此類推。

（四）	Delete
首先須用Search找出要刪除的數字位置。
最初並不將數字直接刪除，而是執行軟刪除——將欲刪除的數字標記為不可用，但仍保留數字。直到單個陣列Ai中欲刪除的數字達到陣列長度的一半，再一次處理陣列中所有數字。處理方式為：若前一陣列Ai-1為空，將Ai中剩餘數字移入前一陣列；若非，則將前一陣列與剩餘數字合併，放入原陣列Ai。

（五）	紅黑樹
使用C++函式庫中的set來實作，其特性為：
* Set中的元素皆已排序
* Set中沒有重複的原素
* 底層結構為紅黑樹

可使用count()、insert()、erase()來完成搜尋、插入與刪除的動作。

